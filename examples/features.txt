Functionality:

- storage abstraction

  storage Counter {
    value: Uint
    get () {
      return value
    }
    increment () {
      value += 1
    }
  }

- sugar for error code

  revert -> 'Error'

- dynamic dispatch

  call token ERC20.transfer(recipient, 10)
  read token ERC20.totalSupply()
  let approveData = ERC20.approve(recipient, 50)
  call token approveData

- try / catch

  try {
    c = a + b
  } catch (e) {
    c -= 1
  }

- event declarations outside contracts

  event Transfer {
    from: Address
    to: Address
    value: Uint
  }

- built in safe-math

  let a = 5 * 10 ** 18
  let b = 2 ** 256
  return a + b -> 'Overflow'

- reentrancy safe (This should be possible using static analysis)

  locked notVulnerable () {
    call external Foo.foo()
    storage += 1
  }

- built in fixed precision number

  let num: Number = 1.5
  num *= 50
  check(num == 75)

- built in datatypes

  Uint (Equivalent to uint256)
  Int (Equivalent to int256)
  Number (Fixed 128 bits 18 decimals)
  Boolean
  String (ascii only)
  Byte (Equivalent to bytes1)
  Address (Equivalent to bytes20)
  Bytes (Equivalent to bytes)
  Bytes32 (Equivalent to bytes32)
